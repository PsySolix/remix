---
title: Preparing for v2
order: 1
---

# Preparing for v2

All v2 APIs and behaviors are available in v1 with [Future Flags][future-flags]. They can be enabled one at a time to avoid development disruption of your project. After you have enabled all flags, upgrading to v2 should be a non-breaking upgrade.

## File System Route Convention

#### Upgrading without changing files

You can keep using the old convention with `@remix-run/route-convention` even after upgrading to v2 if you don't want to make the change right now (or ever, it's just a convention and you can use whatever file organization you prefer).

```shellscript
npm i @remix-run/route-convention
```

```js filename=remix.config.js
const {
  createRoutesFromFolders,
} = require("@remix-run/route-convention");

module.exports = {
  future: {
    // makes the warning go away in v1.15
    v2_routeConvention: true,
  },

  routes(defineRoutes) {
    // uses the v1 convention, works in v1.15+ and v2
    return createRoutesFromFolders(defineRoutes, "routes");
  },
};
```

#### Upgrading to the new convention

- Route nesting is now created by dots (`.`) in file names instead of folder nesting
- `suffixed_` underscores in segments opt-out of nesting with a potentially matching parent route instead of dots (`.`).
- `_prefixed` underscores in segments create layout routes without a path instead of a `__double` underscore prefix.
- `_index.tsx` files create index routes instead of `index.tsx`

A routes folder that looks like this in v1:

```txt bad
routes
├── __auth
│   ├── login.tsx
│   ├── logout.tsx
│   └── signup.tsx
├── __public
│   ├── about-us.tsx
│   ├── contact.tsx
│   └── index.tsx
├── dashboard
│   ├── calendar
│   │   ├── $day.tsx
│   │   └── index.tsx
│   ├── projects
│   │   ├── $projectId
│   │   │   ├── collaborators.tsx
│   │   │   ├── edit.tsx
│   │   │   ├── index.tsx
│   │   │   ├── settings.tsx
│   │   │   └── tasks.$taskId.tsx
│   │   ├── $projectId.tsx
│   │   └── new.tsx
│   ├── calendar.tsx
│   ├── index.tsx
│   └── projects.tsx
├── __auth.tsx
├── __public.tsx
└── dashboard.calendar.$projectId.print.tsx
```

Becomes this with `v2_routeConvention`:

```
routes
├── _auth.login.tsx
├── _auth.logout.tsx
├── _auth.signup.tsx
├── _auth.tsx
├── _public._index.tsx
├── _public.about-us.tsx
├── _public.contact.tsx
├── _public.tsx
├── dashboard._index.tsx
├── dashboard.calendar.$day.tsx
├── dashboard.calendar.$projectId._index.tsx
├── dashboard.calendar.$projectId.collaborators.tsx
├── dashboard.calendar.$projectId.edit.tsx
├── dashboard.calendar.$projectId.settings.tsx
├── dashboard.calendar.$projectId.tasks.$taskId.tsx
├── dashboard.calendar.$projectId.tsx
├── dashboard.calendar._index.tsx
├── dashboard.calendar.new.tsx
├── dashboard.calendar.tsx
├── dashboard.projects.tsx
└── dashboard_.calendar.$projectId.print.tsx
```

Note that parent routes are now grouped together instead of having dozens of routes between them (like the auth routes). Routes with the same path but not the same nesting (like `dashboard` and `dashboard_`) also group together.

With the new convention, any route can be a directory with a `route.tsx` file inside to define the route module. This enables co-location of modules with the route they're used in:

For example, we can move `_public.tsx` to `_public/route.tsx` and then co-locate modules the route uses:

```txt
routes
├── _auth.tsx
├── _public
│   ├── footer.tsx
│   ├── header.tsx
│   └── route.tsx
├── _public._index.tsx
├── _public.about-us.tsx
└── etc.
```

For more background on this change, see the [Original Proposal][flat-routes].

## CatchBoundary and ErrorBoundary

```js filename=remix.config.js
module.exports = {
  future: {
    v2_errorBoundary: true,
  },
};
```

In v1, a thrown `Response` will render the closest `CatchBoundary` while all other unhandled exceptions render the `ErrorBoundary`. In v2 there is no `CatchBoundary` and all unhandled exceptions will render the `ErrorBoundary`, response or otherwise.

Additionally, the error is no longer passed to `ErrorBoundary` as props but is accessed with the `useRouteError` hook.

```js bad filename=v1
import { useCatch } from "@remix-run/react";

export function CatchBoundary() {
  const caught = useCatch();

  return (
    <div>
      <h1>Oops</h1>
      <p>Status: {caught.status}</p>
      <p>{caught.data.message}</p>
    </div>
  );
}

export function ErrorBoundary({ error }) {
  console.error(error);
  return (
    <div>
      <h1>Uh oh ...</h1>
      <p>Something went wrong</p>
      <pre>{error.message || "Unknown error"}</pre>
    </div>
  );
}
```

Becomes:

```js filename=v2
import {
  useRouteError,
  isRouteErrorResponse,
} from "@remix-run/react";

export function ErrorBoundary() {
  const error = useRouteError();

  // when true, this is what used to go to `CatchBoundary`
  if (isRouteErrorResponse(error)) {
    return (
      <div>
        <h1>Oops</h1>
        <p>Status: {error.status}</p>
        <p>{error.data.message}</p>
      </div>
    );
  }

  return (
    <div>
      <h1>Uh oh ...</h1>
      <p>Something went wrong.</p>
      <pre>{error.message || "Unknown error"}</pre>
    </div>
  );
}
```

## `useTransition`

This hook is now called `useNavigation` to avoid confusion with the recent React hook by the same name. It also no longer has the `type` field and flattens the `submission` object into the `navigation` object itself.

```tsx bad filename=v1
import { useTransition } from "@remix-run/react";

function SomeComponent() {
  let transition = useTransition();
  transition.submission.formData;
  transition.submission.formMethod;
  transition.submission.formAction;
  transition.type;
}
```

```tsx filename=v2
import { useNavigation } from "@remix-run/react";

function SomeComponent() {
  let navigation = useNavigation();
  // these keys are flattened
  navigation.formData;
  navigation.formMethod;
  navigation.formAction;

  // this key is removed
  navigation.type;
}
```

If you were using `navigation.type` you can use `navigation.state`, `navigation.formData`, and/or `useActionData` (or some combination of them all) to get the same behavior as before.

## `useFetcher`

Like `useNavigation`, `useFetcher` has flattened the `submission` and removed the `type` field.

```tsx bad filename=v1
import { useFetcher } from "@remix-run/react";

function SomeComponent() {
  let fetcher = useTransition();
  fetcher.submission.formData;
  fetcher.submission.formMethod;
  fetcher.submission.formAction;
  fetcher.type;
}
```

```tsx filename=v2
import { useNavigation } from "@remix-run/react";

function SomeComponent() {
  let fetcher = useTransition();

  // these keys are flattened
  fetcher.formData;
  fetcher.formMethod;
  fetcher.formAction;

  // this key is removed
  fetcher.type;
}
```

You can derive the previous `fetcher.type` with the following examples. Keep in mind, there's probably a simpler way to get the same behavior, usually checking `fetcher.state`, `fetcher.formData` or the data returned from an action on `fetcher.data` can get the UX you're looking for. Feel free to ask us in Discord and we'll help you out :D

```js
function Component() {
  let fetcher = useFetcher();

  // fetcher.type === "done"
  let isDone =
    fetcher.state === "idle" && fetcher.data != null;

  // fetcher.type === "actionSubmission"
  let isActionSubmission = fetcher.state === "submitting";

  // fetcher.type === "actionReload"
  let isActionReload =
    fetcher.state === "loading" &&
    fetcher.formMethod != null &&
    fetcher.formMethod != "get" &&
    // If we returned data, we must be reloading
    fetcher.data != null;

  // fetcher.type === "actionRedirect"
  let isActionRedirect =
    fetcher.state === "loading" &&
    fetcher.formMethod != null &&
    navigation.formMethod != "get" &&
    // If we have no data we must have redirected
    fetcher.data == null;

  // fetcher.type === "loaderSubmission"
  let isLoaderSubmission =
    navigation.state === "loading" &&
    navigation.state.formMethod === "get";

  // fetcher.type === "normalLoad"
  let isNormalLoad =
    navigation.state === "loading" &&
    navigation.state.formMethod == null;
}
```

## `formMethod`

```js filename=remix.config.js
module.exports = {
  future: {
    v2_normalizeFormMethod: true,
  },
};
```

Multiple APIs return the `formMethod` of a submission. In v1 they return a lowercase version of the method but in v2 they return the UPPERCASE version. This is to bring it in line with HTTP and `fetch` specifications.

```jsx
function Something() {
  let navigation = useNavigation();
  let fetcher = useFetcher();

  // v1
  navigation.formMethod === "post";
  fetcher.formMethod === "post";

  // v2
  navigation.formMethod === "POST";
  fetcher.formMethod === "POST";
}

export function shouldRevalidate({ formMethod }) {
  // v1
  formMethod === "post";
  // v2
  formMethod === "POST";
}
```

## `browserBuildDirectory`

In your `remix.config.js`, rename `browserBuildDirectory` to `assetsBuildDirectory`.

```ts bad filename=remix.config.js lines=[2]
module.exports = {
  browserBuildDirectory: "./public/build",
};
```

```ts filename=remix.config.js lines=[2]
module.exports = {
  assetsBuildDirectory: "./public/build",
};
```

## `serverBuildDirectory`

In your `remix.config.js`, rename `serverBuildDirectory` to `serverBuildPath` and specify a module path, not a directory.

```ts bad filename=remix.config.js lines=[2]
module.exports = {
  serverBuildDirectory: "./build",
};
```

```ts filename=remix.config.js lines=[2]
module.exports = {
  serverBuildDirectory: "./build/index.js",
};
```

Remix used to create more than a single module for the server but it now creates a single file.

## `serverBuildTarget`

TODO: link to table

Instead of specifying a build target, use the following [Remix Config][remix-config] options to generate the server build your server target expects:

- `publicPath`
- `serverBuildPath`
- `serverConditions`
- `serverDependenciesToBundle`
- `serverMainFields`
- `serverMinify`
- `serverModuleFormat`
- `serverPlatform`

This change allows Remix to deploy to more JavaScript runtimes, servers, and hosts without Remix source code needing to know about them.

---

We hope your upgrade went smoothly! You should now be able to upgrade to v2 without any issues and without changing any code.

[future-flags]: ./api-development-strategy
[remix-config]: ../file-conventions/remix-config
[flat-routes]: https://github.com/remix-run/remix/discussions/4482
